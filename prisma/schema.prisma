// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// -----------------------------------------------------
// USER ROLES
// -----------------------------------------------------

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

// -----------------------------------------------------
// USER (identità unica cross-canale)
// -----------------------------------------------------

model User {
  id String @id @default(cuid())

  // Authentication - Clerk integration for web chat
  clerkId String? @unique
  email   String? @unique

  // Guest / anonymous mode
  // Guest users can chat before registering; they should NOT get the full trial.
  isGuest          Boolean   @default(false)
  guestAbuseIdHash String?   @unique // e.g. hash of phone number or other identifier
  guestConvertedAt DateTime? // set when the guest account is merged/converted

  // Role-based access control
  role UserRole @default(USER)

  // Relationships
  profile            Profile?
  preferences        Preferences?
  memories           Memory[]
  messages           Message[]
  chats              Chat[]
  dailyUsage         DailyUsage[]
  identities         ChannelIdentity[]
  consumedLinkTokens ChannelLinkToken[] @relation("ChannelLinkTokenConsumedBy")
  subscription       Subscription?
  sessionSummaries   SessionSummary[]
  archivedSessions   ArchivedSession[]
  voiceUsage         VoiceUsage[]

  lastActivityAt DateTime  @default(now())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedAt      DateTime? // Soft delete

  @@index([role])
  @@index([email])
  @@index([isGuest])
  @@index([deletedAt])
  @@index([lastActivityAt])
}

// -----------------------------------------------------
// CHANNEL IDENTITY (una identità per ogni canale: es. WhatsApp=numero telefono)
// -----------------------------------------------------

model ChannelIdentity {
  id String @id @default(cuid())

  channel    Channel @default(WHATSAPP)
  externalId String // e.g.: WhatsApp phone number, Telegram user ID, Instagram PSID

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([channel, externalId])
  @@index([userId])
  @@index([channel])
}

// -----------------------------------------------------
// CHANNEL LINK TOKENS (one-time linking flow)
// -----------------------------------------------------

model ChannelLinkToken {
  id String @id @default(cuid())

  channel   Channel
  tokenHash String  @unique

  // External identity to link (e.g. Telegram user id)
  externalId String
  chatId     String

  expiresAt  DateTime
  consumedAt DateTime?

  consumedByUserId String?
  consumedByUser   User?   @relation("ChannelLinkTokenConsumedBy", fields: [consumedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([channel, externalId])
  @@index([expiresAt])
}

enum Channel {
  WEB
  WHATSAPP
  TELEGRAM
  // FUTURE: TELEGRAM, INSTAGRAM, MESSENGER, EMAIL, IOS_APP, ANDROID_APP
}

// -----------------------------------------------------
// CHAT (conversation sessions)
// -----------------------------------------------------

enum ChatVisibility {
  PRIVATE
  PUBLIC
}

model Chat {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  title      String? // Auto-generated or user-provided
  visibility ChatVisibility @default(PRIVATE)

  messages  Message[]
  artifacts Artifact[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete

  @@index([userId, createdAt(sort: Desc)])
  @@index([visibility])
  @@index([deletedAt])
}

// -----------------------------------------------------
// MESSAGE (supporta testo, media, template, location, audio, ecc.)
// -----------------------------------------------------

model Message {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Chat reference (for multi-chat support)
  chatId String?
  chat   Chat?   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  channel   Channel          @default(WHATSAPP)
  direction MessageDirection
  role      MessageRole

  // Message content and media
  type    MessageType @default(TEXT)
  content String? // Text content (backward compatible, also stores simple text)
  parts   Json? // AI SDK v5 message parts format

  mediaUrl  String? // Media URL: images, audio, video, documents, stickers
  mediaType String? // MIME type e.g.: image/jpeg, audio/ogg

  externalMessageId String? // External message ID from WhatsApp/Telegram/Instagram
  metadata          Json? // Dynamic payload (location, template params, button events, etc.)

  // -----------------------------------------------------
  // AI TRACKING (for ASSISTANT messages only)
  // -----------------------------------------------------
  model            String? // e.g.: "x-ai/grok-4.1-fast:free", "google/gemini-2.5-flash"
  inputTokens      Int? // Input tokens (prompt)
  outputTokens     Int? // Output tokens generated
  reasoningTokens  Int? // Reasoning tokens (for models that support it)
  reasoningContent String? // Reasoning process content
  toolCalls        Json? // Array of tool calls made [{name, args, result}]
  ragUsed          Boolean? @default(false) // Whether RAG was used for this response
  ragChunksCount   Int? // Number of RAG chunks used
  costUsd          Float? // Cost in USD for this response
  generationTimeMs Int? // Total generation time in ms
  reasoningTimeMs  Int? // Reasoning time in ms (if available)
  feedback         Int? // User feedback: -1 = negative, 0 = neutral, 1 = positive

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // Soft delete

  // Relationships
  attachments Attachment[]
  artifacts   Artifact[]   @relation("MessageArtifacts")

  @@unique([channel, externalMessageId])
  @@index([userId, channel, createdAt])
  @@index([chatId, createdAt])
  @@index([externalMessageId])
  @@index([role, createdAt])
  @@index([direction, createdAt])
  @@index([type])
  @@index([userId, role, createdAt])
  @@index([model, createdAt])
  @@index([deletedAt])
}

enum MessageDirection {
  INBOUND // utente → Anthon
  OUTBOUND // Anthon → utente
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  STICKER
  TEMPLATE
  LOCATION
  CONTACT
  UNKNOWN
}

// -----------------------------------------------------
// PROFILE (informazioni di coaching dell’utente)
// -----------------------------------------------------

model Profile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // User coaching information
  name       String?
  sport      String?
  goal       String?
  experience String?
  birthday   DateTime?
  notes      String?   @db.Text // Use TEXT for potentially long notes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------
// PREFERENCES (tono, stile, lingua, notifiche)
// -----------------------------------------------------

model Preferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tone         String? // e.g.: "calm", "energetic", "professional"
  mode         String? // e.g.: "coaching", "friendly", "direct"
  language     String?  @default("IT") // IT, EN, etc.
  push         Boolean? @default(true) // Push notifications enabled by default
  voiceEnabled Boolean? @default(true) // Voice messages enabled (false = Quiet Mode)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------
// MEMORY (memoria persistente condivisa tra tutti i canali)
// -----------------------------------------------------

model Memory {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  key   String
  value Json

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([userId, key]) // Ensure unique keys per user
  @@index([userId, key])
}

// -----------------------------------------------------
// SESSION SUMMARY (persistent cache for session summaries)
// -----------------------------------------------------

model SessionSummary {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String @unique // Composite of start/end timestamps
  summary   String @db.Text

  createdAt DateTime @default(now())
  expiresAt DateTime

  @@index([userId])
  @@index([expiresAt])
}

// -----------------------------------------------------
// ARCHIVED SESSION (long-term storage of summarized sessions)
// -----------------------------------------------------

model ArchivedSession {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  startDate DateTime
  endDate   DateTime
  summary   String   @db.Text

  // Metrics preserved from the session
  messageCount Int

  createdAt DateTime @default(now())

  @@index([userId, startDate])
}

// -----------------------------------------------------
// RAG DOCUMENTS (Metodo Sincro, PDF, ecc.)
// -----------------------------------------------------

model RagDocument {
  id     String  @id @default(cuid())
  title  String
  url    String?
  source String? // Source identifier (e.g., "training_manual", "knowledge_base")

  chunks RagChunk[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([source])
}

// -----------------------------------------------------
// RAG CHUNKS (embedding pgvector)
// -----------------------------------------------------

model RagChunk {
  id         String      @id @default(cuid())
  documentId String
  document   RagDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  content   String                       @db.Text
  embedding Unsupported("vector(1536)")?
  index     Int // Chunk sequence number within document

  createdAt DateTime @default(now())
  // Note: Vector index is created via raw SQL migration (HNSW index)
  // See: prisma/migrations/20251202120000_fix_vector_index/migration.sql

  @@index([documentId])
  @@index([documentId, index])
}

// -----------------------------------------------------
// MODEL PRICING (prezzi per calcolo costi AI)
// NOTE: Removed - replaced by TokenLens which fetches pricing from OpenRouter API
// -----------------------------------------------------

// -----------------------------------------------------
// ARTIFACT (generated code, text, etc.)
// -----------------------------------------------------

enum ArtifactKind {
  CODE
  TEXT
  SHEET
  IMAGE
}

model Artifact {
  id        String   @id @default(cuid())
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  messageId String?
  message   Message? @relation("MessageArtifacts", fields: [messageId], references: [id], onDelete: Cascade)

  title    String
  kind     ArtifactKind
  language String? // Programming language if kind=CODE

  versions ArtifactVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([chatId])
  @@index([messageId])
}

model ArtifactVersion {
  id         String   @id @default(cuid())
  artifactId String
  artifact   Artifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  content       String // Actual artifact content
  blobUrl       String? // Vercel Blob URL for large content
  versionNumber Int     @default(1)

  createdAt DateTime @default(now())

  @@index([artifactId, versionNumber(sort: Desc)])
}

// -----------------------------------------------------
// ATTACHMENT (file uploads)
// -----------------------------------------------------

model Attachment {
  id        String   @id @default(cuid())
  messageId String?
  message   Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  name        String // Original filename
  contentType String // MIME type
  size        Int // Size in bytes
  blobUrl     String // Vercel Blob URL

  createdAt DateTime @default(now())

  @@index([messageId])
}

// -----------------------------------------------------
// DAILY USAGE (rate limiting & analytics)
// -----------------------------------------------------

model DailyUsage {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  date         DateTime @db.Date // UTC date
  requestCount Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)
  totalCostUsd Float    @default(0)

  updatedAt DateTime @updatedAt

  @@unique([userId, date])
  @@index([userId, date(sort: Desc)])
}

// -----------------------------------------------------
// SUBSCRIPTION (tracking trial/conversioni)
// -----------------------------------------------------

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
}

model Subscription {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status              SubscriptionStatus @default(TRIAL)
  clerkSubscriptionId String?            @unique // Clerk Billing subscription ID

  // Trial tracking
  trialStartedAt DateTime? @default(now()) // When trial started
  trialEndsAt    DateTime? // When trial expires

  // Conversion tracking
  convertedAt DateTime? // When converted to paid
  canceledAt  DateTime? // When subscription was canceled

  // Plan information
  planId   String? // Plan ID (from Clerk)
  planName String? // Plan name for reference

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([trialEndsAt])
  @@index([userId, status])
  @@index([status, trialEndsAt])
}

// -----------------------------------------------------
// VOICE USAGE (tracking Eleven Labs voice generation)
// -----------------------------------------------------

model VoiceUsage {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  generatedAt    DateTime @default(now())
  characterCount Int // Characters sent to Eleven Labs
  costUsd        Float? // Estimated cost in USD
  channel        Channel  @default(TELEGRAM) // Which channel triggered the voice

  @@index([userId, generatedAt(sort: Desc)])
  @@index([generatedAt])
}

// -----------------------------------------------------
// BENCHMARK (AI model evaluation system)
// -----------------------------------------------------

model BenchmarkRun {
  id String @id @default(cuid())

  name        String // Human-readable run name, e.g. "December 2024 Evaluation"
  description String? @db.Text

  // Models tested in this run
  models String[] // Array of model IDs tested

  // Aggregated scores
  status    BenchmarkStatus @default(PENDING)
  startedAt DateTime?
  endedAt   DateTime?

  // Admin review
  reviewedBy  String? // Admin user ID who reviewed
  reviewedAt  DateTime?
  reviewNotes String?   @db.Text
  approved    Boolean?

  totalTests      Int   @default(0)
  completedTests  Int   @default(0)
  currentProgress Json? // { testCaseId, modelId, startedAt }

  results BenchmarkResult[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([createdAt(sort: Desc)])
}

enum BenchmarkStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

model BenchmarkResult {
  id    String       @id @default(cuid())
  runId String
  run   BenchmarkRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  // Test case identification
  testCaseId String
  category   BenchmarkCategory
  modelId    String

  // Collected metrics
  inferenceTimeMs Int
  ttftMs          Int?
  inputTokens     Int
  outputTokens    Int
  reasoningTokens Int?
  costUsd         Float
  responseText    String   @db.Text
  toolCalls       Json? // Array of {name, args, result}
  sessionUsed     Json? // {messageCount, sessions}
  memoriesUsed    String[] // Array of memory keys used

  // AI Judge scores
  toolUsageScore          Float? // 0-10
  toolUsageReasoning      String? @db.Text
  writingQualityScore     Float? // 0-10
  writingQualityReasoning String? @db.Text

  // Critique fields (Chain of Thought)
  toolUsageCritique      Json? // Structured critique object
  writingQualityCritique Json? // Structured critique object

  overallScore Float // 0-10 (AI judge 1 score)

  // Second judge scores (for consensus)
  judge2ToolUsageScore          Float?
  judge2ToolUsageReasoning      String? @db.Text
  judge2ToolUsageCritique       Json?
  judge2WritingQualityScore     Float?
  judge2WritingQualityReasoning String? @db.Text
  judge2WritingQualityCritique  Json?
  judge2OverallScore            Float?

  // Consensus metrics
  consensusScore    Float? // Average of both judges
  judgeDisagreement Float? // Absolute difference between judges
  flaggedForReview  Boolean @default(false) // True if disagreement > 3

  // Admin evaluation (weight: 0.6 admin + 0.4 judge)
  adminScore      Float? // 0-10 admin rating
  adminReasoning  String?   @db.Text
  adminReviewedBy String? // Admin user ID
  adminReviewedAt DateTime?
  finalScore      Float? // Weighted: 0.6 * adminScore + 0.4 * overallScore

  createdAt DateTime @default(now())

  @@index([runId])
  @@index([modelId])
  @@index([category])
  @@index([testCaseId])
  @@index([runId, modelId])
}

enum BenchmarkCategory {
  TOOL_USAGE
  WRITING_QUALITY
}

model BenchmarkTestCase {
  id               String            @id @default(cuid())
  externalId       String?           @unique // Original ID from JSON if any
  category         BenchmarkCategory
  name             String
  description      String?           @db.Text
  setup            Json // TestCaseSetup format
  userMessage      String            @db.Text
  expectedBehavior Json // ToolUsageExpected | WritingQualityExpected
  tags             String[]
  version          Int               @default(1)
  isActive         Boolean           @default(true)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([category])
  @@index([isActive])
}
