// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// -----------------------------------------------------
// USER ROLES
// -----------------------------------------------------

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

// -----------------------------------------------------
// USER (identità unica cross-canale)
// -----------------------------------------------------

model User {
  id          String       @id @default(cuid())

  // Solo se userai Clerk (per web chat)
  clerkId     String?      @unique
  email       String?      @unique

  // Role-based access control
  role        UserRole     @default(USER)

  // Relazioni
  profile     Profile?
  preferences Preferences?
  memories    Memory[]
  messages    Message[]
  chats       Chat[]
  dailyUsage  DailyUsage[]
  identities  ChannelIdentity[]
  subscription Subscription?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// -----------------------------------------------------
// CHANNEL IDENTITY (una identità per ogni canale: es. WhatsApp=numero telefono)
// -----------------------------------------------------

model ChannelIdentity {
  id          String    @id @default(cuid())

  channel     Channel   @default(WHATSAPP)
  externalId  String    // es: numero whatsapp, telegram user id, instagram psid

  userId      String?
  user        User?     @relation(fields: [userId], references: [id])

  createdAt   DateTime  @default(now())

  @@unique([channel, externalId])
  @@index([userId])
}

enum Channel {
  WHATSAPP
  // FUTURO: WEB, TELEGRAM, INSTAGRAM, MESSENGER, EMAIL, IOS_APP, ANDROID_APP
}

// -----------------------------------------------------
// CHAT (conversation sessions)
// -----------------------------------------------------

enum ChatVisibility {
  PRIVATE
  PUBLIC
}

model Chat {
  id          String         @id @default(cuid())
  userId      String
  user        User           @relation(fields: [userId], references: [id])
  
  title       String?        // Auto-generated or user-provided
  visibility  ChatVisibility @default(PRIVATE)
  
  messages    Message[]
  artifacts   Artifact[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId, createdAt(sort: Desc)])
}

// -----------------------------------------------------
// MESSAGE (supporta testo, media, template, location, audio, ecc.)
// -----------------------------------------------------

model Message {
  id        String        @id @default(cuid())
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  
  // Chat reference (for multi-chat support)
  chatId    String?
  chat      Chat?         @relation(fields: [chatId], references: [id], onDelete: Cascade)

  channel   Channel       @default(WHATSAPP)
  direction MessageDirection
  role      MessageRole

  // Type: TEXT, IMAGE, AUDIO, VIDEO, DOCUMENT, TEMPLATE, LOCATION, etc.
  type      MessageType   @default(TEXT)

  content   String?        // solo per TEXT (backward compat, also stores simple text)
  parts     Json?          // AI SDK v5 message parts format

  mediaUrl    String?      // immagini, audio, video, documenti, sticker
  mediaType   String?      // MIME type es: image/jpeg, audio/ogg

  externalMessageId String? // ID messaggio lato WhatsApp/Telegram/Instagram
  metadata Json?            // payload dinamico (location, template params, button events, ecc.)

  // -----------------------------------------------------
  // AI TRACKING (solo per messaggi ASSISTANT)
  // -----------------------------------------------------
  model             String?   // es: "x-ai/grok-4.1-fast:free", "google/gemini-2.5-flash"
  inputTokens       Int?      // token di input (prompt)
  outputTokens      Int?      // token di output generati
  reasoningTokens   Int?      // token di reasoning (per modelli che lo supportano)
  reasoningContent  String?   // contenuto del processo di reasoning
  toolCalls         Json?     // array di tool calls effettuate [{name, args, result}]
  ragUsed           Boolean?  // se il RAG è stato usato per questa risposta
  ragChunksCount    Int?      // numero di chunk RAG usati
  costUsd           Float?    // costo in USD per questa risposta
  generationTimeMs  Int?      // tempo totale di generazione in ms
  reasoningTimeMs   Int?      // tempo di reasoning in ms (se disponibile)

  createdAt DateTime @default(now())

  // Relations
  attachments Attachment[]
  artifacts   Artifact[]    @relation("MessageArtifacts")

  @@index([userId, channel, createdAt])
  @@index([chatId, createdAt])
  @@index([externalMessageId])
  @@index([role, createdAt])
}

enum MessageDirection {
  INBOUND   // utente → Anthon
  OUTBOUND  // Anthon → utente
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  STICKER
  TEMPLATE
  LOCATION
  CONTACT
  UNKNOWN
}

// -----------------------------------------------------
// PROFILE (informazioni di coaching dell’utente)
// -----------------------------------------------------

model Profile {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])

  name        String?
  sport       String?
  goal        String?
  experience  String?
  birthday    DateTime?
  notes       String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// -----------------------------------------------------
// PREFERENCES (tono, stile, lingua, notifiche)
// -----------------------------------------------------

model Preferences {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])

  tone       String?   // es: "calmo", "energico", "professionale"
  mode       String?   // es: "coaching", "friendly", "diretto"
  language   String?   // IT, EN, ecc.
  push       Boolean?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

// -----------------------------------------------------
// MEMORY (memoria persistente condivisa tra tutti i canali)
// -----------------------------------------------------

model Memory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  key       String
  value     Json

  createdAt DateTime @default(now())

  @@index([userId, key])
}

// -----------------------------------------------------
// RAG DOCUMENTS (Metodo Sincro, PDF, ecc.)
// -----------------------------------------------------

model RagDocument {
  id        String   @id @default(cuid())
  title     String
  url       String?
  source    String?

  chunks    RagChunk[]

  createdAt DateTime @default(now())
}

// -----------------------------------------------------
// RAG CHUNKS (embedding pgvector)
// -----------------------------------------------------

model RagChunk {
  id         String        @id @default(cuid())
  documentId String
  document   RagDocument   @relation(fields: [documentId], references: [id])

  content    String
  embedding  Unsupported("vector(4096)")?
  index      Int

  createdAt  DateTime @default(now())

  @@index([documentId])
  // Note: Vector index is created via raw SQL migration (HNSW index)
  // See: prisma/migrations/20251202120000_fix_vector_index/migration.sql
}

// -----------------------------------------------------
// MODEL PRICING (prezzi per calcolo costi AI)
// NOTE: Removed - replaced by TokenLens which fetches pricing from OpenRouter API
// -----------------------------------------------------

// -----------------------------------------------------
// ARTIFACT (generated code, text, etc.)
// -----------------------------------------------------

enum ArtifactKind {
  CODE
  TEXT
  SHEET
  IMAGE
}

model Artifact {
  id        String       @id @default(cuid())
  chatId    String
  chat      Chat         @relation(fields: [chatId], references: [id], onDelete: Cascade)
  messageId String?
  message   Message?     @relation("MessageArtifacts", fields: [messageId], references: [id], onDelete: SetNull)
  
  title     String
  kind      ArtifactKind
  language  String?      // Programming language if kind=CODE
  
  versions  ArtifactVersion[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([chatId])
  @@index([messageId])
}

model ArtifactVersion {
  id            String   @id @default(cuid())
  artifactId    String
  artifact      Artifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)
  
  content       String   // Actual artifact content
  blobUrl       String?  // Vercel Blob URL for large content
  versionNumber Int      @default(1)
  
  createdAt     DateTime @default(now())
  
  @@index([artifactId, versionNumber(sort: Desc)])
}

// -----------------------------------------------------
// ATTACHMENT (file uploads)
// -----------------------------------------------------

model Attachment {
  id          String   @id @default(cuid())
  messageId   String?  // Optional - can be attached later
  message     Message?  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  name        String   // Original filename
  contentType String   // MIME type
  size        Int      // Size in bytes
  blobUrl     String   // Vercel Blob URL
  
  createdAt   DateTime @default(now())
  
  @@index([messageId])
}

// -----------------------------------------------------
// DAILY USAGE (rate limiting & analytics)
// -----------------------------------------------------

model DailyUsage {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  date         DateTime @db.Date    // UTC date
  requestCount Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)
  totalCostUsd Float    @default(0)
  
  updatedAt    DateTime @updatedAt
  
  @@unique([userId, date])
  @@index([userId, date(sort: Desc)])
}

// -----------------------------------------------------
// SUBSCRIPTION (tracking trial/conversioni)
// -----------------------------------------------------

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
}

model Subscription {
  id                  String             @id @default(cuid())
  userId              String             @unique
  user                User               @relation(fields: [userId], references: [id])

  status              SubscriptionStatus @default(TRIAL)
  clerkSubscriptionId String?            @unique  // ID subscription da Clerk Billing

  trialStartedAt      DateTime?          // quando ha iniziato il trial
  trialEndsAt         DateTime?          // quando scade il trial
  convertedAt         DateTime?          // quando è passato a pagante
  canceledAt          DateTime?          // quando ha cancellato
  
  planId              String?            // ID del piano (da Clerk)
  planName            String?            // nome del piano per reference

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([status])
  @@index([trialEndsAt])
  @@index([userId, status])
}
