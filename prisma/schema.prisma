// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// -----------------------------------------------------
// USER ROLES
// -----------------------------------------------------

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

// -----------------------------------------------------
// USER (identità unica cross-canale)
// -----------------------------------------------------

model User {
  id String @id @default(cuid())

  // Authentication - Clerk integration for web chat
  clerkId String? @unique
  email   String? @unique

  // Role-based access control
  role UserRole @default(USER)

  // Relationships
  profile      Profile?
  preferences  Preferences?
  memories     Memory[]
  messages     Message[]
  chats        Chat[]
  dailyUsage   DailyUsage[]
  identities   ChannelIdentity[]
  subscription Subscription?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([email])
}

// -----------------------------------------------------
// CHANNEL IDENTITY (una identità per ogni canale: es. WhatsApp=numero telefono)
// -----------------------------------------------------

model ChannelIdentity {
  id String @id @default(cuid())

  channel    Channel @default(WHATSAPP)
  externalId String // e.g.: WhatsApp phone number, Telegram user ID, Instagram PSID

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@unique([channel, externalId])
  @@index([userId])
  @@index([channel])
}

enum Channel {
  WHATSAPP
  // FUTURO: WEB, TELEGRAM, INSTAGRAM, MESSENGER, EMAIL, IOS_APP, ANDROID_APP
}

// -----------------------------------------------------
// CHAT (conversation sessions)
// -----------------------------------------------------

enum ChatVisibility {
  PRIVATE
  PUBLIC
}

model Chat {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  title      String? // Auto-generated or user-provided
  visibility ChatVisibility @default(PRIVATE)

  messages  Message[]
  artifacts Artifact[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, createdAt(sort: Desc)])
  @@index([visibility])
}

// -----------------------------------------------------
// MESSAGE (supporta testo, media, template, location, audio, ecc.)
// -----------------------------------------------------

model Message {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Chat reference (for multi-chat support)
  chatId String?
  chat   Chat?   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  channel   Channel          @default(WHATSAPP)
  direction MessageDirection
  role      MessageRole

  // Message content and media
  type    MessageType @default(TEXT)
  content String? // Text content (backward compatible, also stores simple text)
  parts   Json? // AI SDK v5 message parts format

  mediaUrl  String? // Media URL: images, audio, video, documents, stickers
  mediaType String? // MIME type e.g.: image/jpeg, audio/ogg

  externalMessageId String? // External message ID from WhatsApp/Telegram/Instagram
  metadata          Json? // Dynamic payload (location, template params, button events, etc.)

  // -----------------------------------------------------
  // AI TRACKING (for ASSISTANT messages only)
  // -----------------------------------------------------
  model            String? // e.g.: "x-ai/grok-4.1-fast:free", "google/gemini-2.5-flash"
  inputTokens      Int? // Input tokens (prompt)
  outputTokens     Int? // Output tokens generated
  reasoningTokens  Int? // Reasoning tokens (for models that support it)
  reasoningContent String? // Reasoning process content
  toolCalls        Json? // Array of tool calls made [{name, args, result}]
  ragUsed          Boolean? @default(false) // Whether RAG was used for this response
  ragChunksCount   Int? // Number of RAG chunks used
  costUsd          Float? // Cost in USD for this response
  generationTimeMs Int? // Total generation time in ms
  reasoningTimeMs  Int? // Reasoning time in ms (if available)
  feedback         Int? // User feedback: -1 = negative, 0 = neutral, 1 = positive

  createdAt DateTime @default(now())

  // Relationships
  attachments Attachment[]
  artifacts   Artifact[]   @relation("MessageArtifacts")

  @@index([userId, channel, createdAt])
  @@index([chatId, createdAt])
  @@index([externalMessageId])
  @@index([role, createdAt])
  @@index([direction, createdAt])
  @@index([type])
  @@index([userId, role, createdAt])
}

enum MessageDirection {
  INBOUND // utente → Anthon
  OUTBOUND // Anthon → utente
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  STICKER
  TEMPLATE
  LOCATION
  CONTACT
  UNKNOWN
}

// -----------------------------------------------------
// PROFILE (informazioni di coaching dell’utente)
// -----------------------------------------------------

model Profile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // User coaching information
  name       String?
  sport      String?
  goal       String?
  experience String?
  birthday   DateTime?
  notes      String?   @db.Text // Use TEXT for potentially long notes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------
// PREFERENCES (tono, stile, lingua, notifiche)
// -----------------------------------------------------

model Preferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tone     String? // e.g.: "calm", "energetic", "professional"
  mode     String? // e.g.: "coaching", "friendly", "direct"
  language String?  @default("IT") // IT, EN, etc.
  push     Boolean? @default(true) // Push notifications enabled by default

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// -----------------------------------------------------
// MEMORY (memoria persistente condivisa tra tutti i canali)
// -----------------------------------------------------

model Memory {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  key   String
  value Json

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([userId, key]) // Ensure unique keys per user
  @@index([userId, key])
}

// -----------------------------------------------------
// RAG DOCUMENTS (Metodo Sincro, PDF, ecc.)
// -----------------------------------------------------

model RagDocument {
  id        String   @id @default(cuid())
  title     String
  url       String?
  source    String?  // Source identifier (e.g., "training_manual", "knowledge_base")

  chunks    RagChunk[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  
  @@index([source])
}

// -----------------------------------------------------
// RAG CHUNKS (embedding pgvector)
// -----------------------------------------------------

model RagChunk {
  id         String      @id @default(cuid())
  documentId String
  document   RagDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  content   String                       @db.Text
  embedding Unsupported("vector(4096)")?
  index     Int // Chunk sequence number within document

  createdAt DateTime @default(now())
  // Note: Vector index is created via raw SQL migration (HNSW index)
  // See: prisma/migrations/20251202120000_fix_vector_index/migration.sql

  @@index([documentId])
  @@index([documentId, index])
}

// -----------------------------------------------------
// MODEL PRICING (prezzi per calcolo costi AI)
// NOTE: Removed - replaced by TokenLens which fetches pricing from OpenRouter API
// -----------------------------------------------------

// -----------------------------------------------------
// ARTIFACT (generated code, text, etc.)
// -----------------------------------------------------

enum ArtifactKind {
  CODE
  TEXT
  SHEET
  IMAGE
}

model Artifact {
  id        String   @id @default(cuid())
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  messageId String?
  message   Message? @relation("MessageArtifacts", fields: [messageId], references: [id], onDelete: SetNull)

  title    String
  kind     ArtifactKind
  language String? // Programming language if kind=CODE

  versions ArtifactVersion[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([chatId])
  @@index([messageId])
}

model ArtifactVersion {
  id         String   @id @default(cuid())
  artifactId String
  artifact   Artifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  content       String // Actual artifact content
  blobUrl       String? // Vercel Blob URL for large content
  versionNumber Int     @default(1)

  createdAt DateTime @default(now())

  @@index([artifactId, versionNumber(sort: Desc)])
}

// -----------------------------------------------------
// ATTACHMENT (file uploads)
// -----------------------------------------------------

model Attachment {
  id        String   @id @default(cuid())
  messageId String? // Optional - can be attached later
  message   Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  name        String // Original filename
  contentType String // MIME type
  size        Int // Size in bytes
  blobUrl     String // Vercel Blob URL

  createdAt DateTime @default(now())

  @@index([messageId])
}

// -----------------------------------------------------
// DAILY USAGE (rate limiting & analytics)
// -----------------------------------------------------

model DailyUsage {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  date         DateTime @db.Date // UTC date
  requestCount Int      @default(0)
  inputTokens  Int      @default(0)
  outputTokens Int      @default(0)
  totalCostUsd Float    @default(0)

  updatedAt DateTime @updatedAt

  @@unique([userId, date])
  @@index([userId, date(sort: Desc)])
}

// -----------------------------------------------------
// SUBSCRIPTION (tracking trial/conversioni)
// -----------------------------------------------------

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
}

model Subscription {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status              SubscriptionStatus @default(TRIAL)
  clerkSubscriptionId String?            @unique // Clerk Billing subscription ID

  // Trial tracking
  trialStartedAt DateTime? @default(now()) // When trial started
  trialEndsAt    DateTime? // When trial expires

  // Conversion tracking
  convertedAt DateTime? // When converted to paid
  canceledAt  DateTime? // When subscription was canceled

  // Plan information
  planId   String? // Plan ID (from Clerk)
  planName String? // Plan name for reference

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([trialEndsAt])
  @@index([userId, status])
  @@index([status, trialEndsAt])
}
